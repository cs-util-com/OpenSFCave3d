<!-- (Do NOT remove this entire comment block at the top of the HTML file!)

### **1. Game Overview**

* **Concept:** A 3D take on the classic sfcave game.  
* **Perspective:** First-person view, with the plane represented as a single dot (hitbox).  
* **Core Challenge:** Navigate a procedurally generated tunnel that narrows over time while avoiding obstacles.

---

### **2. Core Gameplay Mechanics**

* **Movement:**  
  * **Vertical Control:** A tap (on mobile) or mouse click (on PC) provides an upward impulse. Gravity continuously pulls the dot downward.  
  * **Horizontal Control:** Sensor-based input on mobile (via tilt) and mouse movement on PC allow the player to steer left and right.  
* **Collision & Life:**  
  * The player has 1HP. Colliding with any obstacle or leaving the tunnel results in an immediate game over.

---

### **3. Tunnel and Obstacles**

* **Tunnel:**  
  * **Procedural Generation:** Levels are generated based on a seed. The seed is displayed to the player for sharing and replay purposes.  
  * **Dynamic Difficulty:** As the player progresses, the tunnel gradually narrows, increasing the challenge.  
* **Obstacles:**  
  * Static and brightly colored obstacles are positioned throughout the tunnel.  
  * They are meant to be easily recognizable hazards that the player must avoid.  
  * Obstacle density remains constant regardless of tunnel narrowing.

---

### **4. Collectible Power-Ups**

There are three types of time-limited power-ups, with durations that accumulate if the same type is collected while an effect is already active:

* **Slow-Motion Effect:**  
  * Temporarily slows down time (affecting overall gameplay speed).  
* **Score Boost:**  
  * Increases bonus points received (e.g., multiplier for distance or actions) while active.  
* **Auto-Firing Weapon:**  
  * **Behavior:** Automatically fires projectiles every 1 second.  
  * **Direction:** Projectiles are shot in the direction the dot is currently steering (incorporating both vertical and horizontal movement).  
  * **Impact:** When a projectile hits an obstacle, the obstacle is immediately destroyed and bonus points are awarded.

---

### **5. Ghost Player Functionality**

* **Purpose:** Motivates players to compete against their own previous best runs.  
* **Recording:** Only the playerâ€™s movement (position and timing) is recorded.  
* **Usage:** Ghost runs are available when playing with the same seed.

---

### **6. Level Seed Management**

* **Visibility:** The seed is displayed on-screen, allowing players to copy and share it.  
* **Usage:** Players can either reuse a seed to challenge their previous ghost runs or change the seed to generate a new level layout.

---

### **7. Scoring System**

* **Base Score:** Continuously accumulates based on the distance traveled.  
* **Bonuses:**  
  * Additional bonus points are awarded for every obstacle destroyed by the auto-firing weapon.  
  * Additional bonus points are given for each power-up collected.  
* **Tuning:** Specific bonus values are tunable and can be adjusted during playtesting.

---

### **8. Game Over and Feedback**

* **Trigger:** The game ends immediately when the player's dot collides with an obstacle or exits the tunnel.  
* **Game Over Screen:** Upon game termination, display the following final statistics:  
  * Final Score  
  * Distance Traveled  
  * Number of Obstacles Destroyed  
  * Number of Power-Ups Collected  
  * The Seed used for that run  
* **Feedback:** Appropriate visual and audio cues (e.g., sound effects or screen shake) may be included to enhance the impact of game over.

---

### **9. Control Methods for Different Platforms**

* **Mobile:**  
  * **Steering:** Left/right via sensor-based tilt.  
  * **Vertical Movement:** Tap for upward impulse.  
* **PC (Testing):**  
  * **Steering:** Mouse movement or keyboard (if desired) for left/right.  
  * **Vertical Movement:** Mouse click for upward impulse.


## General Instructions (Do not remove!)

1. Keep this comment block in the code! Also do not remove any comments in the code below.
2. If any text is displayed, the font should be CONSOLAS, monospace.
3. There is no backend; all data needs to be stored locally.
4. Simplify the code if possible (without removing comments or the functionality described above).
5. You MUST keep all comments in the code below, even if you think they are redundant.
6. Always respond with the full new html file (including these comments here), additional explanations are not necessary. 
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Open 3D SFCave</title>
  <style>
    html, body {
      margin: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
      background: #000;
      font-family: Consolas, monospace;
      color: white;
    }
    #renderCanvas {
      width: 100%;
      height: 100%;
      touch-action: none;
    }
    #uiOverlay {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
    }
    #gameOver {
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 20px;
      border: 2px solid white;
      display: none;
      text-align: center;
    }
  </style>
  <!-- Include Babylon.js and Cannon.js (for physics) from CDN -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/cannon.js"></script>
</head>
<body>
  <canvas id="renderCanvas"></canvas>
  <div id="uiOverlay">
    <div id="scoreDisplay">Score: 0</div>
    <div id="seedDisplay">Seed: 12345</div>
  </div>
  <div id="gameOver">
    <h1>Game Over</h1>
    <div id="finalStats"></div>
    <button id="restartBtn">Restart</button>
  </div>

  <script>
    // ==== Global Variables ====
    let canvas = document.getElementById("renderCanvas");
    let engine = new BABYLON.Engine(canvas, true);
    let scene;

    // Game settings & tunable variables.
    // Adjust these so the INITIAL_TUNNEL_RADIUS clearly matters.
    const GRAVITY = -1;                 
    const UP_IMPULSE = 1;                  
    const FORWARD_SPEED = 30;               
    const HORIZONTAL_SENSITIVITY = 0.01;   
    const INITIAL_TUNNEL_RADIUS = 20;       // Adjusted to make changes noticeable.
    const NARROWING_RATE = 0.01;            // Increased so shrinking is visible.
    const MIN_TUNNEL_RADIUS = 4;            
    const OBSTACLE_INTERVAL = 10;           
    const OBSTACLE_SIZE = 0.5;
    const TUNNEL_LENGTH = 10000; 

    // Score & state
    let score = 0;
    let gameRunning = true;
    let seed = 12345;

    // For ghost run recording (simplified)
    let ghostPositions = [];

    // Arrays for obstacles
    let obstacles = [];

    // UI elements
    const scoreDisplay = document.getElementById("scoreDisplay");
    const seedDisplay = document.getElementById("seedDisplay");
    const gameOverDiv = document.getElementById("gameOver");
    const finalStatsDiv = document.getElementById("finalStats");
    const restartBtn = document.getElementById("restartBtn");

    // References to key game objects
    let tunnel;             // The visual + physical tunnel mesh
    let playerMesh;         // The player's sphere mesh (physics impostor)

    // ==== Scene Setup ====
    function createScene() {
      scene = new BABYLON.Scene(engine);

      // Enable physics (using CannonJSPlugin)
      scene.enablePhysics(
        new BABYLON.Vector3(0, GRAVITY, 0),
        new BABYLON.CannonJSPlugin()
      );

      // Basic light
      let light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0,1,0), scene);

      // 1) Create the tunnel first
      createTunnel();

      // 2) Create the player mesh next (so it's available for registering collisions)
      createPlayer();

      // 3) Create obstacles
      generateObstacles();

      // Register collision with the tunnel walls => game over if player hits them.
      playerMesh.physicsImpostor.registerOnPhysicsCollide(
        tunnel.physicsImpostor,
        function(main, collided) {
          if (gameRunning) {
            gameOver();
          }
        }
      );

      // Create a first-person camera, parented to the player mesh.
      let camera = new BABYLON.UniversalCamera("camera", new BABYLON.Vector3(0,0,0), scene);
      camera.attachControl(canvas, true);
      camera.parent = playerMesh;
      camera.position.z = 0;

      // Register input handlers
      setupInputHandlers();

      return scene;
    }

    // ==== Create Tunnel ====
    function createTunnel() {
      let path = [];
      let radii = [];

      // Build path/radii from z=0 up to TUNNEL_LENGTH, ensuring we shrink over distance.
      for (let z = 0; z <= TUNNEL_LENGTH; z += 5) {
        // We make the tunnel shrink by NARROWING_RATE * z, clamped by MIN_TUNNEL_RADIUS.
        let radius = Math.max(INITIAL_TUNNEL_RADIUS - z * NARROWING_RATE, MIN_TUNNEL_RADIUS);
        path.push(new BABYLON.Vector3(0, 0, z));
        radii.push(radius);
      }

      tunnel = BABYLON.MeshBuilder.CreateTube("tunnel", {
        path: path,
        radii: radii,
        tessellation: 32,
        cap: BABYLON.Mesh.NO_CAP,
        sideOrientation: BABYLON.Mesh.BACKSIDE
      }, scene);

      tunnel.material = new BABYLON.StandardMaterial("tunnelMat", scene);
      tunnel.material.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);
      tunnel.material.specularColor = new BABYLON.Color3(0, 0, 0);

      // Physics impostor for the tunnel so we can collide from inside.
      tunnel.physicsImpostor = new BABYLON.PhysicsImpostor(
        tunnel,
        BABYLON.PhysicsImpostor.MeshImpostor,
        { mass: 0, friction: 0.2, restitution: 0 },
        scene
      );
    }

    // ==== Create Player ====
    function createPlayer() {
      // A small sphere representing the player's "dot"
      playerMesh = BABYLON.MeshBuilder.CreateSphere("playerMesh", { diameter: 0.5 }, scene);
      playerMesh.position = new BABYLON.Vector3(0, 0, 0);

      // Dynamic physics body
      playerMesh.physicsImpostor = new BABYLON.PhysicsImpostor(
        playerMesh,
        BABYLON.PhysicsImpostor.SphereImpostor,
        { mass: 1, friction: 0.0, restitution: 0 },
        scene
      );

      // Initial forward velocity along Z.
      playerMesh.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(0, 0, FORWARD_SPEED));

      // Player material (optional visual)
      let pmat = new BABYLON.StandardMaterial("playerMat", scene);
      pmat.diffuseColor = new BABYLON.Color3(0, 0.5, 1);
      playerMesh.material = pmat;
    }

    // ==== Obstacle Generation ====
    function generateObstacles() {
      obstacles = [];
      for (let z = OBSTACLE_INTERVAL; z < TUNNEL_LENGTH; z += OBSTACLE_INTERVAL) {
        // The tunnel radius at this z, used to place an obstacle within its bounds.
        let tunnelRadius = Math.max(INITIAL_TUNNEL_RADIUS - z * NARROWING_RATE, MIN_TUNNEL_RADIUS);
        let angle = Math.random() * Math.PI * 2;
        let radius = Math.random() * (tunnelRadius - OBSTACLE_SIZE - 0.5);
        let x = Math.cos(angle) * radius;
        let y = Math.sin(angle) * radius;

        let obstacleMesh = BABYLON.MeshBuilder.CreateBox("obstacle" + z, { size: OBSTACLE_SIZE }, scene);
        obstacleMesh.position = new BABYLON.Vector3(x, y, z);
        obstacleMesh.material = new BABYLON.StandardMaterial("obsMat" + z, scene);
        obstacleMesh.material.diffuseColor = new BABYLON.Color3(Math.random(), Math.random(), Math.random());

        // Static physics body for each obstacle to collide with player.
        obstacleMesh.physicsImpostor = new BABYLON.PhysicsImpostor(
          obstacleMesh,
          BABYLON.PhysicsImpostor.BoxImpostor,
          { mass: 0, friction: 0.2, restitution: 0 },
          scene
        );

        // Collision event => game over if player hits obstacle.
        playerMesh.physicsImpostor.registerOnPhysicsCollide(
          obstacleMesh.physicsImpostor,
          function(main, collided) {
            if (gameRunning) {
              gameOver();
            }
          }
        );

        obstacles.push(obstacleMesh);
      }
    }

    // ==== Input Handling ====
    function setupInputHandlers() {
      // On pointer down => upward impulse
      canvas.addEventListener("pointerdown", function() {
        if (!gameRunning) return;
        let currentVel = playerMesh.physicsImpostor.getLinearVelocity();
        currentVel.y = UP_IMPULSE;
        playerMesh.physicsImpostor.setLinearVelocity(currentVel);
      });

      // Mouse move => horizontal control on PC
      canvas.addEventListener("pointermove", function(e) {
        if (!gameRunning) return;
        let currentVel = playerMesh.physicsImpostor.getLinearVelocity();
        currentVel.x += e.movementX * HORIZONTAL_SENSITIVITY;
        playerMesh.physicsImpostor.setLinearVelocity(currentVel);
      });

      // Sensor-based input on mobile
      if (window.DeviceOrientationEvent) {
        window.addEventListener("deviceorientation", function(e) {
          if (!gameRunning) return;
          if (e.gamma !== null) {
            let tilt = BABYLON.Scalar.Clamp(e.gamma / 45, -1, 1);
            let currentVel = playerMesh.physicsImpostor.getLinearVelocity();
            currentVel.x += tilt * HORIZONTAL_SENSITIVITY * 1.5;
            playerMesh.physicsImpostor.setLinearVelocity(currentVel);
          }
        });
      }
    }

    // ==== Main Update Loop ====
    function updateGame() {
      if (!gameRunning) return;

      // Record ghost position (for future ghost run overlay)
      ghostPositions.push(playerMesh.position.clone());

      // Force consistent forward speed along Z.
      let currentVel = playerMesh.physicsImpostor.getLinearVelocity();
      currentVel.z = FORWARD_SPEED;
      playerMesh.physicsImpostor.setLinearVelocity(currentVel);

      // Update score (distance traveled * 10)
      score = playerMesh.position.z * 10;
      scoreDisplay.innerText = "Score: " + Math.floor(score);

      // If the player goes beyond the tunnel length => out of bounds => game over
      if (playerMesh.position.z > TUNNEL_LENGTH) {
        gameOver();
      }
    }

    // ==== Game Over ====
    function gameOver() {
      gameRunning = false;
      engine.stopRenderLoop();
      finalStatsDiv.innerHTML = `
        <p>Final Score: ${Math.floor(score)}</p>
        <p>Distance: ${playerMesh.position.z.toFixed(2)}</p>
        <p>Obstacles: ${obstacles.length}</p>
        <p>Seed: ${seed}</p>
      `;
      gameOverDiv.style.display = "block";
    }

    // ==== Create and Run Scene ====
    let sceneToRender = createScene();
    scene.registerBeforeRender(updateGame);

    engine.runRenderLoop(function() {
      if (scene) {
        scene.render();
      }
    });

    // Handle resizing
    window.addEventListener("resize", function() {
      engine.resize();
    });

    // Restart button => reload the page for simplicity
    restartBtn.addEventListener("click", function() {
      location.reload();
    });
  </script>
</body>
</html>